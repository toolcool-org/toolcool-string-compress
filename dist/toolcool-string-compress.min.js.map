{
  "version": 3,
  "sources": ["../src/encoder.ts", "../src/index.ts"],
  "sourcesContent": ["const TCEncoder = (text: string) => {\n\n    const searchBuffer: Map<number, number> = new Map();\n    const result = [];\n\n    const encoder = new TextEncoder();\n    const view = encoder.encode(text); // Uint8Array\n    const len = view.length;\n\n    let i=0;\n    while(i<len){\n        const byte = view[i];\n\n        if(searchBuffer.has(byte)){\n            // The character is repeated ---> we can create the token.\n            // Try to maximize how much text the token is referencing.\n            let previousCharacterIndex = searchBuffer.get(byte) ?? 0;\n            let currentCharacterIndex = i;\n            const tokenOffset = i - previousCharacterIndex;\n\n            const tokenValue = [];\n            while(text[previousCharacterIndex] === text[currentCharacterIndex] && currentCharacterIndex < len){\n                tokenValue.push(view[currentCharacterIndex]);\n                previousCharacterIndex++;\n                currentCharacterIndex++;\n            }\n\n            const token = `<${ tokenOffset },${ tokenValue.length }>`;\n            if(tokenValue.length > token.length){\n                // place the token\n                const tokenUint8Array = encoder.encode(token);\n                result.push(...tokenUint8Array);\n            }\n            else{\n                // token size is bigger that the actual text --> place the text\n                result.push(...tokenValue);\n            }\n\n            i += tokenValue.length;\n        }\n        else{\n            // New non-repeated characters just added to the result as a plain text.\n            searchBuffer.set(byte, i);\n            result.push(byte)\n            i++;\n        }\n    }\n\n    return new TextDecoder().decode(new Uint8Array(result));\n};\n\nexport default TCEncoder;", "import TCEncoder from './encoder';\n\ndeclare global {\n    interface Window {\n        TCCompress: typeof TCEncoder;\n    }\n}\n\nwindow.TCCompress = TCEncoder;"],
  "mappings": ";;;;;;;MAAA,IAAMA,EAAaC,GAAiB,CAApC,IAAAC,EAEI,IAAMC,EAAoC,IAAI,IACxCC,EAAS,CAAC,EAEVC,EAAU,IAAI,YACdC,EAAOD,EAAQ,OAAOJ,CAAI,EAC1BM,EAAMD,EAAK,OAEbE,EAAE,EACN,KAAMA,EAAED,GAAI,CACR,IAAME,EAAOH,EAAKE,GAElB,GAAGL,EAAa,IAAIM,CAAI,EAAE,CAGtB,IAAIC,GAAyBR,EAAAC,EAAa,IAAIM,CAAI,IAArB,KAAAP,EAA0B,EACnDS,EAAwBH,EACtBI,EAAcJ,EAAIE,EAElBG,EAAa,CAAC,EACpB,KAAMZ,EAAKS,KAA4BT,EAAKU,IAA0BA,EAAwBJ,GAC1FM,EAAW,KAAKP,EAAKK,EAAsB,EAC3CD,IACAC,IAGJ,IAAMG,EAAQ,IAAKF,KAAiBC,EAAW,UAC/C,GAAGA,EAAW,OAASC,EAAM,OAAO,CAEhC,IAAMC,EAAkBV,EAAQ,OAAOS,CAAK,EAC5CV,EAAO,KAAK,GAAGW,CAAe,CAClC,MAGIX,EAAO,KAAK,GAAGS,CAAU,EAG7BL,GAAKK,EAAW,MACpB,MAGIV,EAAa,IAAIM,EAAMD,CAAC,EACxBJ,EAAO,KAAKK,CAAI,EAChBD,GAER,CAEA,OAAO,IAAI,YAAY,EAAE,OAAO,IAAI,WAAWJ,CAAM,CAAC,CAC1D,EAEOY,EAAQhB,EC3Cf,OAAO,WAAaiB",
  "names": ["TCEncoder", "text", "_a", "searchBuffer", "result", "encoder", "view", "len", "i", "byte", "previousCharacterIndex", "currentCharacterIndex", "tokenOffset", "tokenValue", "token", "tokenUint8Array", "encoder_default", "encoder_default"]
}
